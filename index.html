
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>土壌調査（ECODRR）Web GIS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; background: #000; }

    /* 左の操作パネル */
    .panel {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: #fff; padding: 12px; border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,.25);
      width: 330px; font-size: 14px;
      max-height: calc(100vh - 20px); overflow-y: auto;
    }
    .panel h3 { margin: 0 0 8px; font-size: 16px; }
    .group { border-top: 1px solid #eee; margin-top: 10px; padding-top: 10px; }
    .row { display: flex; align-items: center; gap: 6px; margin: 5px 0; }
    .row label { width: 120px; }
    .row input[type="range"] { flex: 1; }
    .row input[type="color"] { width: 40px; height: 26px; padding: 0; }
    .small { font-size: 12px; }
  </style>
</head>

<body>

<div id="map"></div>

<!-- 左側 UI（Aレイアウト） -->
<div class="panel" id="panel">
  <h3>レイヤ操作（秩父市・大田地区）</h3>

  <!-- 背景 OSM -->
  <div class="group">
    <b>背景（OSM）</b>
    <div class="row">
      <label>透明度</label>
      <input id="baseOpacity" type="range" min="0" max="1" step="0.05" value="1">
    </div>
  </div>

  <!-- タイルレイヤ（市域マスク適用） -->
  <div class="group">
    <b>タイルレイヤ</b>

    <!-- TWI -->
    <div class="row"><input type="checkbox" id="twiToggle"><label for="twiToggle">TWI（湿潤度）</label></div>
    <div class="row"><label class="small">透明度</label><input id="twiOpacity" type="range" min="0" max="1" step="0.05" value="0.8"></div>
    <div class="row"><label class="small">色相 Hue</label><input id="twiHue" type="range" min="0" max="360" value="0"></div>
    <div class="row"><label class="small">彩度 Sat</label><input id="twiSat" type="range" min="0" max="4" step="0.1" value="1"></div>
    <div class="row"><label class="small">明度 Bri</label><input id="twiBri" type="range" min="0.3" max="2" step="0.1" value="1"></div>

    <!-- HAND -->
    <div class="row"><input type="checkbox" id="handToggle"><label for="handToggle">HAND（鉛直距離）</label></div>
    <div class="row"><label class="small">透明度</label><input id="handOpacity" type="range" min="0" max="1" step="0.05" value="0.8"></div>
    <div class="row"><label class="small">Hue</label><input id="handHue" type="range" min="0" max="360" value="0"></div>
    <div class="row"><label class="small">Sat</label><input id="handSat" type="range" min="0" max="4" step="0.1" value="1"></div>
    <div class="row"><label class="small">Bri</label><input id="handBri" type="range" min="0.3" max="2" step="0.1" value="1"></div>

    <!-- 自然的景観 -->
    <div class="row"><input type="checkbox" id="shizenToggle"><label for="shizenToggle">自然的景観</label></div>
    <div class="row"><label class="small">透明度</label><input id="shizenOpacity" type="range" min="0" max="1" step="0.05" value="0.8"></div>
    <div class="row"><label class="small">Hue</label><input id="shizenHue" type="range" min="0" max="360" value="0"></div>
    <div class="row"><label class="small">Sat</label><input id="shizenSat" type="range" min="0" max="4" step="0.1" value="1"></div>
    <div class="row"><label class="small">Bri</label><input id="shizenBri" type="range" min="0.3" max="2" step="0.1" value="1"></div>

    <!-- 水田 -->
    <div class="row"><input type="checkbox" id="suidenToggle"><label for="suidenToggle">水田占有率</label></div>
    <div class="row"><label class="small">透明度</label><input id="suidenOpacity" type="range" min="0" max="1" step="0.05" value="0.8"></div>
    <div class="row"><label class="small">Hue</label><input id="suidenHue" type="range" min="0" max="360" value="0"></div>
    <div class="row"><label class="small">Sat</label><input id="suidenSat" type="range" min="0" max="4" step="0.1" value="1"></div>
    <div class="row"><label class="small">Bri</label><input id="suidenBri" type="range" min="0.3" max="2" step="0.1" value="1"></div>
  </div>

  <!-- 区境（大田地区） -->
  <div class="group">
    <b>区境（大田地区）</b>
    <div class="row"><input type="checkbox" id="boundaryToggle" checked><label for="boundaryToggle">chichibuoota.geojson</label></div>
    <div class="row"><label class="small">線色</label><input type="color" id="boundaryColor" value="#ff0066"></div>
    <div class="row"><label class="small">太さ</label><input id="boundaryWeight" type="range" min="1" max="6" step="1" value="3"></div>
    <button id="fitBoundary" class="small">範囲へ</button>
  </div>

  <!-- 土壌ポイント -->
  <div class="group">
    <b>土壌ポイント</b>
    <div class="row"><input type="checkbox" id="pointsToggle" checked><label for="pointsToggle">表示</label></div>
    <div class="row small">
      <label><input type="radio" name="ptMode" value="ec" checked> ECスケール</label>
      <label><input type="radio" name="ptMode" value="mono"> 単色</label>
      <input id="pointColor" type="color" value="#ffaa00">
    </div>
    <div class="row"><label class="small">サイズ</label><input id="pointSize" type="range" min="4" max="14" step="1" value="8"></div>
  </div>
</div>

<script>
/* ==========================
   基本：地図とOSM
========================== */
const map = L.map("map", { center: [36.055, 139.07], zoom: 13 });
const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  { maxZoom: 19, opacity: 1 }).addTo(map);

// パネルからのクリックで地図が動かないように
L.DomEvent.disableClickPropagation(document.getElementById('panel'));
document.getElementById("baseOpacity").addEventListener("input", e =>
  osm.setOpacity(Number(e.target.value))
);

/* ==========================
   市域マスク付きタイルレイヤ
========================== */
// 1) 秩父市のGeoJSONを読み込み
let chichibuMask = null;
fetch("./data/chichibu.geojson")
  .then(r => r.json())
  .then(geo => { chichibuMask = geo; })
  .catch(err => console.warn("chichibu.geojson 読み込み失敗:", err));

// 2) マスク付きタイルクラス（Canvasタイル）
const MaskedTileLayer = L.TileLayer.extend({
  initialize: function(url, options) {
    L.TileLayer.prototype.initialize.call(this, url, options || {});
    this._filter = 'none'; // canvas描画時 filter
  },
  setFilter: function(h,s,b){    // Hue/Sat/Bri を1本の文字列にして保持
    this._filter = `hue-rotate(${h}deg) saturate(${s}) brightness(${b})`;
    this.redraw();
  },
  createTile: function(coords, done) {
    const size = 256;
    const tile = L.DomUtil.create('canvas', 'leaflet-tile');
    tile.width = tile.height = size;
    const ctx = tile.getContext('2d');

    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = this.getTileUrl(coords);

    img.onload = () => {
      // マスクが未読込ならそのまま
      if (!chichibuMask) {
        ctx.filter = this._filter;
        ctx.drawImage(img, 0, 0);
        return done(null, tile);
      }

      // クリップパスを作る
      ctx.save();
      ctx.beginPath();

      const z = coords.z;
      const tileOriginX = coords.x * size;
      const tileOriginY = coords.y * size;

      const geom = chichibuMask.features[0].geometry;
      // Polygon or MultiPolygon どちらでも処理
      const polys = (geom.type === 'MultiPolygon') ? geom.coordinates : [geom.coordinates];

      polys.forEach(polygon => {
        polygon.forEach(ring => {
          ring.forEach((pt, i) => {
            const latlng = L.latLng(pt[1], pt[0]);
            const p = map.project(latlng, z);     // ピクセル座標（ズームz）
            const cx = p.x - tileOriginX;        // タイル内座標
            const cy = p.y - tileOriginY;
            if (i === 0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
          });
          ctx.closePath();
        });
      });

      // クリップしてから描画
      ctx.clip('nonzero'); // 外側を切り落とす
      ctx.filter = this._filter;  // 色変換（Hue/Sat/Bri）
      ctx.drawImage(img, 0, 0);
      ctx.restore();

      done(null, tile);
    };

    img.onerror = () => done(null, tile);
    return tile;
  }
});

// 3) レイヤ生成（最初は非表示。UIでON）
const twiLayer    = new MaskedTileLayer("./data/01_TWI_chichibu/{z}/{x}/{y}.png");
const handLayer   = new MaskedTileLayer("./data/02_HAND_chichibu/{z}/{x}/{y}.png");
const shizenLayer = new MaskedTileLayer("./data/04_SHIZEN_chichibu/{z}/{x}/{y}.png");
const suidenLayer = new MaskedTileLayer("./data/05_suiden_chichibu/{z}/{x}/{y}.png");

/* ==========================
   各レイヤ UI 連携
========================== */
const defs = {
  twi:    {lay:twiLayer,    chk:'twiToggle',    op:'twiOpacity',    h:'twiHue',    s:'twiSat',    b:'twiBri'},
  hand:   {lay:handLayer,   chk:'handToggle',   op:'handOpacity',   h:'handHue',   s:'handSat',   b:'handBri'},
  shizen: {lay:shizenLayer, chk:'shizenToggle', op:'shizenOpacity', h:'shizenHue', s:'shizenSat', b:'shizenBri'},
  suiden: {lay:suidenLayer, chk:'suidenToggle', op:'suidenOpacity', h:'suidenHue', s:'suidenSat', b:'suidenBri'},
};

Object.values(defs).forEach(d => {
  const c = id => document.getElementById(id);
  const chk = c(d.chk), op = c(d.op), h = c(d.h), s = c(d.s), b = c(d.b);

  const applyAll = () => {
    d.lay.setOpacity(Number(op.value));
    d.lay.setFilter(Number(h.value), Number(s.value), Number(b.value));
  };

  chk.addEventListener('change', () => {
    if (chk.checked) { d.lay.addTo(map); applyAll(); }
    else map.removeLayer(d.lay);
  });

  [op,h,s,b].forEach(el => el.addEventListener('input', () => {
    if (!map.hasLayer(d.lay)) return; // OFF中は無視
    applyAll();
  }));
});

/* ==========================
   レイヤコントロール（併用）
========================== */
L.control.layers(
  { "OpenStreetMap": osm },
  {
    "TWI（湿潤度）": twiLayer,
    "HAND（鉛直距離）": handLayer,
    "自然的景観": shizenLayer,
    "水田占有率": suidenLayer
  },
  { collapsed: true }
).addTo(map);

/* ==========================
   大田地区の区境
========================== */
let boundaryLayer = null, boundaryBounds = null;

function loadBoundary() {
  fetch("./data/chichibuoota.geojson")
    .then(r => r.json())
    .then(js => {
      if (boundaryLayer) map.removeLayer(boundaryLayer);
      boundaryLayer = L.geoJSON(js, {
        style: {
          color: document.getElementById("boundaryColor").value,
          weight: Number(document.getElementById("boundaryWeight").value),
          fillOpacity: 0
        }
      }).addTo(map);
      boundaryBounds = boundaryLayer.getBounds();
    })
    .catch(e => console.warn("chichibuoota 読み込み失敗:", e));
}
loadBoundary();

document.getElementById("boundaryToggle").addEventListener("change", e => {
  if (!boundaryLayer) return;
  if (e.target.checked) boundaryLayer.addTo(map);
  else map.removeLayer(boundaryLayer);
});
document.getElementById("boundaryColor").addEventListener("input", () => {
  boundaryLayer && boundaryLayer.setStyle({ color: boundaryColor.value });
});
document.getElementById("boundaryWeight").addEventListener("input", () => {
  boundaryLayer && boundaryLayer.setStyle({ weight: Number(boundaryWeight.value) });
});
document.getElementById("fitBoundary").addEventListener("click", () => {
  if (boundaryBounds && boundaryBounds.isValid()) map.fitBounds(boundaryBounds.pad(0.1));
});

/* ==========================
   土壌ポイント
========================== */
let pointsLayer = null;
let pointMode = "ec";
let monoColor = "#ffaa00";
let pointSize = 8;

function ecColor(v) {
  return v > 0.2 ? "#800026" :
         v > 0.15 ? "#E31A1C" :
         v > 0.10 ? "#FD8D3C" : "#FED976";
}

function loadPoints() {
  fetch("./data/soil_points.geojson", { cache: "no-store" })
    .then(r => r.json())
    .then(js => {
      if (pointsLayer) map.removeLayer(pointsLayer);
      pointsLayer = L.geoJSON(js, {
        pointToLayer: (f, latlng) => {
          const col = (pointMode === "ec") ? ecColor(f.properties?.EC) : monoColor;
          return L.circleMarker(latlng, {
            radius: pointSize, fillColor: col, color: "#000", weight: 1, fillOpacity: 0.9
          });
        }
      });
      if (document.getElementById("pointsToggle").checked) pointsLayer.addTo(map);
    })
    .catch(e => console.warn("soil_points 読み込み失敗:", e));
}
loadPoints();

document.getElementById("pointsToggle").addEventListener("change", e => {
  if (!pointsLayer) return;
  if (e.target.checked) pointsLayer.addTo(map);
  else map.removeLayer(pointsLayer);
});
document.querySelectorAll("input[name='ptMode']").forEach(r => {
  r.addEventListener("change", e => {
    pointMode = e.target.value;
    if (!pointsLayer) return;
    pointsLayer.eachLayer(m => {
      const ec = m.feature?.properties?.EC;
      m.setStyle && m.setStyle({ fillColor: pointMode === "ec" ? ecColor(ec) : monoColor });
    });
  });
});
document.getElementById("pointColor").addEventListener("input", e => {
  monoColor = e.target.value;
  if (pointMode !== "mono" || !pointsLayer) return;
  pointsLayer.eachLayer(m => m.setStyle && m.setStyle({ fillColor: monoColor }));
});
document.getElementById("pointSize").addEventListener("input", e => {
  pointSize = Number(e.target.value);
  if (!pointsLayer) return;
  pointsLayer.eachLayer(m => m.setStyle && m.setStyle({ radius: pointSize }));
});
</script>

</body>
</html>
