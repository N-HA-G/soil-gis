
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>åœŸå£Œèª¿æŸ»ï¼ˆECODRRï¼‰Web GIS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    /* å·¦ä¸Šãƒ‘ãƒãƒ«ï¼ˆUI Aãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰ */
    .panel {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: #fff; padding: 12px; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25); width: 320px;
      font-size: 14px; line-height: 1.5;
      max-height: calc(100vh - 20px); overflow: auto;
    }
    .panel h3 { margin: 0 0 8px; font-size: 16px; }
    .group { border-top: 1px solid #eee; padding-top: 10px; margin-top: 10px; }
    .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .row label { width: 110px; }
    .row input[type="range"] { flex: 1; }
    .row input[type="color"] { width: 44px; height: 28px; padding: 0; border: none; background: transparent; }
    .hint { color: #666; font-size: 12px; }
    .small { font-size: 12px; }
    .btn { padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px; background: #fafafa; cursor: pointer; }
    .btn:hover { background: #f0f0f0; }
  </style>
</head>

<body>
<div id="map"></div>

<!-- ğŸ”§ UI ãƒ‘ãƒãƒ«ï¼ˆå·¦ä¸Šï¼‰ -->
<div class="panel">
  <h3>ãƒ¬ã‚¤ãƒ¤æ“ä½œï¼ˆç§©çˆ¶å¸‚ãƒ»å¤§ç”°åœ°åŒºï¼‰</h3>

  <!-- ãƒ™ãƒ¼ã‚¹ãƒãƒƒãƒ— -->
  <div class="group">
    <b>ãƒ™ãƒ¼ã‚¹ï¼ˆèƒŒæ™¯åœ°å›³ï¼‰</b>
    <div class="row">
      <label for="baseOpacity">èƒŒæ™¯é€æ˜åº¦</label>
      <input id="baseOpacity" type="range" min="0" max="1" step="0.05" value="1">
    </div>
  </div>

  <!-- ã‚¿ã‚¤ãƒ«ãƒ¬ã‚¤ãƒ¤ å€‹åˆ¥ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
  <div class="group">
    <b>ã‚¿ã‚¤ãƒ«ãƒ¬ã‚¤ãƒ¤</b> <span class="hint">ï¼ˆãƒã‚§ãƒƒã‚¯ã§è¡¨ç¤ºON/OFFï¼‰</span>

    <!-- TWI -->
    <div class="row"><input type="checkbox" id="twiToggle"><label for="twiToggle">TWIï¼ˆæ¹¿æ½¤åº¦ï¼‰</label></div>
    <div class="row">
      <label for="twiOpacity" class="small">é€æ˜åº¦</label>
      <input id="twiOpacity" type="range" min="0" max="1" step="0.05" value="0.8">
    </div>
    <div class="row">
      <label for="twiHue" class="small">è‰²ç›¸ï¼ˆHueï¼‰</label>
      <input id="twiHue" type="range" min="0" max="360" step="1" value="0">
    </div>

    <!-- HAND -->
    <div class="row"><input type="checkbox" id="handToggle"><label for="handToggle">HANDï¼ˆé‰›ç›´è·é›¢ï¼‰</label></div>
    <div class="row">
      <label for="handOpacity" class="small">é€æ˜åº¦</label>
      <input id="handOpacity" type="range" min="0" max="1" step="0.05" value="0.8">
    </div>
    <div class="row">
      <label for="handHue" class="small">è‰²ç›¸ï¼ˆHueï¼‰</label>
      <input id="handHue" type="range" min="0" max="360" step="1" value="0">
    </div>

    <!-- è‡ªç„¶çš„æ™¯è¦³ -->
    <div class="row"><input type="checkbox" id="shizenToggle"><label for="shizenToggle">è‡ªç„¶çš„æ™¯è¦³å¤šæ§˜åº¦</label></div>
    <div class="row">
      <label for="shizenOpacity" class="small">é€æ˜åº¦</label>
      <input id="shizenOpacity" type="range" min="0" max="1" step="0.05" value="0.8">
    </div>
    <div class="row">
      <label for="shizenHue" class="small">è‰²ç›¸ï¼ˆHueï¼‰</label>
      <input id="shizenHue" type="range" min="0" max="360" step="1" value="0">
    </div>

    <!-- æ°´ç”° -->
    <div class="row"><input type="checkbox" id="suidenToggle"><label for="suidenToggle">æ°´ç”°å æœ‰ç‡</label></div>
    <div class="row">
      <label for="suidenOpacity" class="small">é€æ˜åº¦</label>
      <input id="suidenOpacity" type="range" min="0" max="1" step="0.05" value="0.8">
    </div>
    <div class="row">
      <label for="suidenHue" class="small">è‰²ç›¸ï¼ˆHueï¼‰</label>
      <input id="suidenHue" type="range" min="0" max="360" step="1" value="0">
    </div>
  </div>

  <!-- åŒºå¢ƒï¼ˆå¤§ç”°åœ°åŒºï¼‰ -->
  <div class="group">
    <b>åŒºå¢ƒï¼ˆç§©çˆ¶å¸‚ãƒ»å¤§ç”°åœ°åŒºï¼‰</b>
    <div class="row"><input type="checkbox" id="boundaryToggle" checked><label for="boundaryToggle">chichibuoota.geojson ã‚’è¡¨ç¤º</label></div>
    <div class="row">
      <label for="boundaryColor" class="small">ç·šè‰²</label>
      <input id="boundaryColor" type="color" value="#1E88E5">
      <button id="fitBoundary" class="btn small">ç¯„å›²ã¸</button>
    </div>
    <div class="row">
      <label for="boundaryWeight" class="small">ç·šã®å¤ªã•</label>
      <input id="boundaryWeight" type="range" min="1" max="6" step="1" value="2">
    </div>
  </div>

  <!-- ãƒã‚¤ãƒ³ãƒˆï¼ˆåœŸå£Œæ¡å–åœ°ç‚¹ï¼‰ -->
  <div class="group">
    <b>åœŸå£Œãƒã‚¤ãƒ³ãƒˆï¼ˆsoil_pointsï¼‰</b>
    <div class="row"><input type="checkbox" id="pointsToggle" checked><label for="pointsToggle">è¡¨ç¤º</label></div>
    <div class="row">
      <label class="small">é…è‰²</label>
      <label class="small"><input type="radio" name="ptMode" value="ec" checked> ECã‚¹ã‚±ãƒ¼ãƒ«</label>
      <label class="small"><input type="radio" name="ptMode" value="mono"> å˜è‰²</label>
      <input id="pointColor" type="color" value="#ff6600" title="å˜è‰²ãƒ¢ãƒ¼ãƒ‰ã®è‰²">
    </div>
    <div class="row">
      <label for="pointSize" class="small">ã‚µã‚¤ã‚º</label>
      <input id="pointSize" type="range" min="4" max="12" step="1" value="7">
    </div>
  </div>

  <div class="group small hint">
    â€» Hue ã¯ PNG/JPEGã‚¿ã‚¤ãƒ«ã«ã‚‚æœ‰åŠ¹ï¼ˆç”»åƒè‰²ã‚’å›ã—ã¾ã™ï¼‰ã€‚  
    â€» åæ˜ ã•ã‚Œãªã„æ™‚ã¯å¯¾è±¡ãƒ¬ã‚¤ãƒ¤ã‚’ä¸€åº¦ONã«ã—ã¦ã‹ã‚‰æ“ä½œã—ã¦ãã ã•ã„ã€‚
  </div>
</div>

<script>
  // ----------------------------
  // åœ°å›³åˆæœŸåŒ– & ãƒ™ãƒ¼ã‚¹
  // ----------------------------
  const map = L.map('map', { center: [36.055, 139.07], zoom: 13 });

  const osm = L.tileLayer(
    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    { maxZoom: 19, opacity: 1 }
  ).addTo(map);

  // ãƒ™ãƒ¼ã‚¹é€æ˜åº¦
  document.getElementById('baseOpacity').addEventListener('input', (e) => {
    osm.setOpacity(Number(e.target.value));
  });

  // ----------------------------
  // ã‚¿ã‚¤ãƒ«ãƒ¬ã‚¤ãƒ¤
  // ----------------------------
  const twiLayer    = L.tileLayer('./data/01_TWI_chichibu/{z}/{x}/{y}.png', { opacity: 0.8, minZoom: 12, maxZoom: 18 });
  const handLayer   = L.tileLayer('./data/02_HAND_chichibu/{z}/{x}/{y}.png', { opacity: 0.8 });
  const shizenLayer = L.tileLayer('./data/04_SHIZEN_chichibu/{z}/{x}/{y}.png', { opacity: 0.8 });
  const suidenLayer = L.tileLayer('./data/05_suiden_chichibu/{z}/{x}/{y}.png', { opacity: 0.8 });

  // åˆæœŸè¡¨ç¤ºã¯å…¨OFFï¼ˆUIã§ONã«ã™ã‚‹ï¼‰
  // twiLayer.addTo(map);

  // ãƒ¬ã‚¤ãƒ¤å®šç¾©ã‚’ã¾ã¨ã‚ã¦ç®¡ç†ï¼ˆHue/Opacityã‚¤ãƒ™ãƒ³ãƒˆã‚’ç°¡å˜ã«ï¼‰
  const tileDefs = {
    twi:    { toggle: 'twiToggle',    opacity: 'twiOpacity',    hue: 'twiHue',    layer: twiLayer },
    hand:   { toggle: 'handToggle',   opacity: 'handOpacity',   hue: 'handHue',   layer: handLayer },
    shizen: { toggle: 'shizenToggle', opacity: 'shizenOpacity', hue: 'shizenHue', layer: shizenLayer },
    suiden: { toggle: 'suidenToggle', opacity: 'suidenOpacity', hue: 'suidenHue', layer: suidenLayer }
  };

  // ã‚¿ã‚¤ãƒ«ã« CSS ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆHueï¼‰ã‚’é©ç”¨
  function applyHueToTileLayer(layer, deg) {
    if (!layer._container) return;
    const imgs = layer._container.querySelectorAll('img.leaflet-tile');
    imgs.forEach(img => { img.style.filter = `hue-rotate(${deg}deg)`; });
  }
  // å°†æ¥èª­ã¿è¾¼ã¾ã‚Œã‚‹ã‚¿ã‚¤ãƒ«ã«ã‚‚åæ˜ ã•ã›ã‚‹
  function hookTileHue(layer, deg) {
    layer.off('tileload'); // äºŒé‡ç™»éŒ²é˜²æ­¢
    layer.on('tileload', (e) => { e.tile.style.filter = `hue-rotate(${deg}deg)`; });
  }

  // å„ãƒ¬ã‚¤ãƒ¤ã®UIã‚¤ãƒ™ãƒ³ãƒˆã‚’æŸã­ã¦ç´ä»˜ã‘
  Object.values(tileDefs).forEach(def => {
    const chk = document.getElementById(def.toggle);
    const op  = document.getElementById(def.opacity);
    const hue = document.getElementById(def.hue);

    // è¡¨ç¤ºON/OFF
    chk.addEventListener('change', () => {
      if (chk.checked) {
        def.layer.addTo(map);
        // ç¾åœ¨ã®Hueã‚’é©ç”¨
        applyHueToTileLayer(def.layer, Number(hue.value));
        hookTileHue(def.layer, Number(hue.value));
        def.layer.setOpacity(Number(op.value));
      } else {
        map.removeLayer(def.layer);
      }
    });

    // é€æ˜åº¦
    op.addEventListener('input', () => {
      def.layer.setOpacity(Number(op.value));
    });

    // Hueï¼ˆè‰²ç›¸ï¼‰
    hue.addEventListener('input', () => {
      const v = Number(hue.value);
      applyHueToTileLayer(def.layer, v);
      hookTileHue(def.layer, v);
    });

    // ãƒ¬ã‚¤ãƒ¤ãŒLayerControlç­‰ã‹ã‚‰å¾Œã§ONã«ãªã£ãŸå ´åˆã«ã‚‚å†é©ç”¨
    map.on('overlayadd', (e) => {
      if (e.layer === def.layer) {
        applyHueToTileLayer(def.layer, Number(hue.value));
        hookTileHue(def.layer, Number(hue.value));
        def.layer.setOpacity(Number(op.value));
        chk.checked = true;
      }
    });
    map.on('overlayremove', (e) => {
      if (e.layer === def.layer) {
        chk.checked = false;
      }
    });
  });

  // ----------------------------
  // ãƒ¬ã‚¤ãƒ¤åˆ‡æ›¿ï¼ˆLeafletæ¨™æº–ã®UIã‚‚ä½µç”¨ï¼‰
  // ----------------------------
  L.control.layers(
    { 'OpenStreetMap': osm },
    {
      'TWIï¼ˆæ¹¿æ½¤åº¦ï¼‰': twiLayer,
      'HANDï¼ˆé‰›ç›´è·é›¢ï¼‰': handLayer,
      'è‡ªç„¶çš„æ™¯è¦³å¤šæ§˜åº¦': shizenLayer,
      'æ°´ç”°å æœ‰ç‡': suidenLayer
    },
    { collapsed: true } // å·¦ãƒ‘ãƒãƒ«ãŒã‚ã‚‹ã®ã§ã“ã¡ã‚‰ã¯æŠ˜ã‚Šç•³ã¿
  ).addTo(map);

  // ----------------------------
  // åŒºå¢ƒï¼ˆå¤§ç”°åœ°åŒºï¼‰ chichibuoota.geojson
  // ----------------------------
  let boundaryLayer = null;
  let boundaryBounds = null;

  function buildBoundary(color = '#1E88E5', weight = 2) {
    if (boundaryLayer) {
      map.removeLayer(boundaryLayer);
      boundaryLayer = null;
    }
    fetch('./data/chichibuoota.geojson', { cache: 'no-store' })
      .then(r => r.json())
      .then(geo => {
        boundaryLayer = L.geoJSON(geo, {
          style: { color, weight, fillOpacity: 0 }
        }).addTo(map);
        boundaryBounds = boundaryLayer.getBounds();
      })
      .catch(err => console.warn('boundary load error', err));
  }
  // åˆæœŸæç”»
  buildBoundary();

  // UI: è¡¨ç¤ºON/OFF
  const boundaryToggle = document.getElementById('boundaryToggle');
  boundaryToggle.addEventListener('change', () => {
    if (!boundaryLayer) return;
    if (boundaryToggle.checked) boundaryLayer.addTo(map);
    else map.removeLayer(boundaryLayer);
  });
  // UI: è‰²ãƒ»å¤ªã•
  const boundaryColor  = document.getElementById('boundaryColor');
  const boundaryWeight = document.getElementById('boundaryWeight');
  function refreshBoundaryStyle() {
    if (boundaryLayer) {
      boundaryLayer.setStyle({
        color: boundaryColor.value,
        weight: Number(boundaryWeight.value),
        fillOpacity: 0
      });
    }
  }
  boundaryColor.addEventListener('input', refreshBoundaryStyle);
  boundaryWeight.addEventListener('input', refreshBoundaryStyle);

  // ç¯„å›²ã¸ãƒ•ã‚£ãƒƒãƒˆ
  document.getElementById('fitBoundary').addEventListener('click', () => {
    if (boundaryBounds && boundaryBounds.isValid()) map.fitBounds(boundaryBounds.pad(0.1));
  });

  // ----------------------------
  // ãƒã‚¤ãƒ³ãƒˆï¼ˆåœŸå£Œï¼‰ soil_points.geojson
  // ----------------------------
  let pointsLayer = null;
  let pointMode   = 'ec'; // 'ec' or 'mono'
  let pointColor  = '#ff6600';
  let pointSize   = 7;

  function getECColor(ec) {
    return ec > 0.2 ? '#800026' :
           ec > 0.15 ? '#E31A1C' :
           ec > 0.10 ? '#FD8D3C' :
                        '#FED976';
  }

  function buildPoints() {
    if (pointsLayer) {
      map.removeLayer(pointsLayer);
      pointsLayer = null;
    }
    fetch('./data/soil_points.geojson', { cache: 'no-store' })
      .then(r => r.json())
      .then(json => {
        pointsLayer = L.geoJSON(json, {
          pointToLayer: (f, latlng) => {
            const ec = f.properties?.EC;
            const fill = (pointMode === 'ec') ? getECColor(ec) : pointColor;
            return L.circleMarker(latlng, {
              radius: pointSize,
              fillColor: fill,
              color: '#000',
              weight: 1,
              fillOpacity: 0.9
            });
          },
          onEachFeature: (f, l) => {
            const p = f.properties || {};
            l.bindPopup(`
              <b>${p.å ´æ‰€å ?? ''}</b><hr>
              field_id: ${p.field_id ?? ''}<br>
              æ¡å–æ—¥: ${p.æ¡å–æ—¥ ?? ''}<br>
              EC: ${p.EC ?? ''}<br>
              pH: ${p.pH ?? ''}<br>
              CEC: ${p.CEC ?? ''}<br>
              C: ${p.C ?? ''}<br>
              N: ${p.N ?? ''}<br>
              BIOTREX: ${p.BIOTREX ?? ''}
            `);
          }
        });
        if (document.getElementById('pointsToggle').checked) {
          pointsLayer.addTo(map);
        }
      })
      .catch(err => console.warn('points load error', err));
  }
  // åˆæœŸæç”»
  buildPoints();

  // ãƒã‚¤ãƒ³ãƒˆUIï¼šè¡¨ç¤ºON/OFF
  document.getElementById('pointsToggle').addEventListener('change', (e) => {
    if (!pointsLayer) return;
    if (e.target.checked) pointsLayer.addTo(map);
    else map.removeLayer(pointsLayer);
  });

  // ãƒã‚¤ãƒ³ãƒˆUIï¼šé…è‰²ãƒ¢ãƒ¼ãƒ‰ï¼ˆECã‚¹ã‚±ãƒ¼ãƒ« / å˜è‰²ï¼‰
  document.querySelectorAll('input[name="ptMode"]').forEach(r => {
    r.addEventListener('change', (e) => {
      pointMode = e.target.value; // 'ec' or 'mono'
      // æ—¢å­˜ãƒ¬ã‚¤ãƒ¤ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
      if (!pointsLayer) return;
      pointsLayer.eachLayer(marker => {
        if (!marker.setStyle) return;
        if (pointMode === 'ec') {
          const ec = marker.feature?.properties?.EC;
          marker.setStyle({ fillColor: getECColor(ec) });
        } else {
          marker.setStyle({ fillColor: pointColor });
        }
      });
    });
  });

  // ãƒã‚¤ãƒ³ãƒˆUIï¼šå˜è‰²ã‚«ãƒ©ãƒ¼
  document.getElementById('pointColor').addEventListener('input', (e) => {
    pointColor = e.target.value;
    if (!pointsLayer || pointMode !== 'mono') return;
    pointsLayer.eachLayer(marker => marker.setStyle && marker.setStyle({ fillColor: pointColor }));
  });

  // ãƒã‚¤ãƒ³ãƒˆUIï¼šã‚µã‚¤ã‚º
  document.getElementById('pointSize').addEventListener('input', (e) => {
    pointSize = Number(e.target.value);
    if (!pointsLayer) return;
    pointsLayer.eachLayer(marker => marker.setStyle && marker.setStyle({ radius: pointSize }));
  });

</script>
</body>
</html>
